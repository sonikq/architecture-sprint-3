# Задание 1. Анализ и планирование

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удалённо включать/выключать отопление в своих домах.
- Система поддерживает только включение/выключение отопления в домах.

**Мониторинг температуры:**

- Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
- Система поддерживает контроль температуры в домах.

### 2. Анализ архитектуры монолитного приложения

- Монолит написан на Java.
- БД: PostgreSQL.
- Взаимодействие между пользователем и монолитом, а также монолитом и внешней системой - синхронное.

### 3. Определение доменов и границы контекстов

Примерные домены:
- Управление отоплением. Получение и обработка команд от пользователя для управления отоплением(вкл/выкл) и мониторинг температуры, также получение данных с физических отопительных устройств и датчиков температуры и сохранение их в базу.
- Управление освещением. Получение и обработка команд от пользователей для управления освещением(вкл/выкл) и отслеживание текущего сосотояния освещения, также получение данных с физических устройств освещения и сохранение их в базу.
- Управление умными воротами. Получение и обработка команд от пользователей для управления воротами(вкл/выкл/установка открытия/закрытия на определенное время) и отслеживание текущего сосотояния ворот, также получение данных с ворот и сохранение их в базу.
- Наблюдение за домом (камеры, сенсоры). Получение и обработка команд от пользователей для наблюдения за домом(просмотреть картинку с выбранной камеры/узнать о передвижениях с помощью сенсоров движения) и отслеживание текущего сосотояния системы наблюдения за домом, также получение данных с камер и сенсоров и сохранение их в базу.
- Управление устройствами. Регистрация новых устройств в системе с последующей записью в базу и отслеживание сосотояния устройств(зарегистрирован/отклонен). 
- Управление пользователями. Авторизация/аутентификация пользователей, получение/обновление информации о пользователе.
- Администрирование и поддержка системы. Помощь при регистрации новых устройств, разбор тикетов.

### **4. Проблемы монолитного решения**

1. Сложности с масштабируемостью и производительностью:
- Монолитная архитектура ограничивает возможности масштабирования системы. В текущем состоянии приложение не позволяет масштабировать отдельные модули, такие как управление устройствами или мониторинг. Для поддержки большого количества новых пользователей и устройств система должна быть гибкой и масштабируемой.
- При увеличении числа подключенных домов или посёлков возрастёт нагрузка на сервер, что может привести к задержкам и ухудшению производительности.

2. Ограниченная гибкость для добавления новых функций:
- Монолитная структура затрудняет добавление новых модулей, таких как управление освещением, воротами и камерами наблюдения. Каждое изменение требует редактирования и тестирования всего приложения.
- Чтобы соответствовать новым бизнес-целям, компании нужно будет внедрять изменения более динамично и независимо, однако в монолите любое добавление или изменение требует полного пересмотра и деплоя всей системы.

3. Невозможность независимого развертывания и обновления:
- В монолитной архитектуре обновление или исправление ошибок требует остановки всего приложения. Это снижает доступность системы, что особенно критично для управления домом, где важна стабильность и непрерывность работы.
- Например, если нужно внести изменения в работу только одного модуля, потребуется провести развертывание всего приложения, что может повлиять на других пользователей и устройства.

4. Отсутствие отказоустойчивости:
- Если один из компонентов приложения выходит из строя, это может повлиять на всю систему. В монолитном приложении сбой в одном модуле (например, при высокой нагрузке) может повлиять на доступность других сервисов.
- В условиях целевой экосистемы, где требуется управление несколькими устройствами и датчиками, монолитное приложение не сможет эффективно справляться с отказами отдельных модулей без угрозы для остальных частей системы.

5. Синхронное взаимодействие и высокая зависимость от сервера:
- В текущем решении все запросы обрабатываются синхронно, что приводит к задержкам при большом числе обращений к серверу. Для IoT-устройств, которые требуют быстрого отклика, это становится серьезным ограничением.
- Асинхронное взаимодействие с датчиками и устройствами повысило бы производительность и стабильность системы, но текущая архитектура монолита не поддерживает такого подхода.

6. Зависимость от специалистов для установки и подключения:
- В настоящее время установка системы требует выезда специалиста, что увеличивает затраты и снижает удобство для клиентов. Монолитное приложение не поддерживает самообслуживание и автоматическую настройку устройств, что становится критическим с ростом числа пользователей.
- Целевая экосистема предполагает, что клиенты смогут сами подключать устройства через стандартные протоколы. Текущая архитектура не приспособлена к такому самообслуживанию.

### Заключение
Переход к микросервисной архитектуре будет способствовать решению всех этих проблем. Микросервисы позволят компании развивать каждый модуль экосистемы независимо, возможно, разными командами с удобным для них стеком, также обеспечат отказоустойчивость, гибкость масштабирования, а также возможность легко добавлять новые функции, соответствующие бизнес-целям компании.

### 5. Визуализация контекста системы — диаграмма С4


### [Диаграмма контекста монолитного приложения](diagrams/context/Monolith.puml)


# Задание 2. Проектирование микросервисной архитектуры

Микросервисы могут стоять за API Gateway и взаимодействовать через шину данных, например Kafka. 
Это обеспечит масштабируемость, асинхронность и упрощение коммуникации между сервисами.

**Диаграмма контейнеров (Containers)**

### [C4 — Уровень контейнеров](diagrams/container/Container.puml)

**Диаграмма компонентов (Components)**


### [C4 — Уровень компонентов](diagrams/component/Component.puml)

**Диаграммы кода (Code)**


- ### [Управление отоплением](diagrams/code/Heating_Service.puml)


- ### [Управление пользователями](diagrams/code/User_Service.puml)

# Задание 3. Разработка ER-диаграммы

### [ER-диаграмма](diagrams/ER.puml)

## Идентификация сущностей и их атрибутов
1. User (Пользователь)
- id — уникальный идентификатор пользователя.
- name — имя пользователя.
- email — email пользователя.
- password_hash — хеш пароля.
- created_at — дата создания пользователя.

2. House (Дом)
- id — уникальный идентификатор дома.
- address — адрес дома.
- user_id — идентификатор пользователя (внешний ключ к User).

3. Device (Устройство)
- id — уникальный идентификатор устройства.
- type_id — идентификатор типа устройства (внешний ключ к DeviceType).
- house_id — идентификатор дома (внешний ключ к House).
- serial_number — серийный номер устройства.
- status — текущее состояние устройства (включено/выключено).
- installed_at — дата установки устройства.

4. DeviceType (Тип устройства)
- id — уникальный идентификатор типа устройства.
- name — название типа устройства (например, «отопление», «освещение»).
- description — описание типа устройства.

5. Module (Модуль)
- id — уникальный идентификатор модуля.
- name — название модуля.
- description — описание модуля.
- created_at — дата создания модуля.

6. TelemetryData (Телеметрия)
- id — уникальный идентификатор записи телеметрии.
- device_id — идентификатор устройства (внешний ключ к Device).
- timestamp — время записи телеметрии.
- temperature — температура (если устройство связано с отоплением).
- power_status — статус включения (для устройств с функцией питания).
- other_data — другие параметры телеметрии (в формате JSON для гибкости).


## Описание связей между сущностями
- User — House: Один пользователь может иметь несколько домов, а домом могут управлять несколько пользователей(семья) (многие-ко-многим). Для этого понадобится связующая таблица Bridge_User_House. 
- House — Device: Один дом может содержать несколько устройств, и каждое устройство привязано к одному дому (один-ко-многим).
- Device — DeviceType: Каждое устройство имеет один тип, но один тип устройства может быть у многих устройств (один-ко-многим).
- Device — TelemetryData: Одно устройство может иметь множество записей телеметрии (один-ко-многим).
- DeviceType — Module: Один тип устройства может быть частью нескольких модулей, а один модуль может включать несколько типов устройств (многие-ко-многим). Для этого понадобится связующая таблица Bridge_Module_DeviceType.
